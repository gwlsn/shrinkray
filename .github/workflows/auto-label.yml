name: Auto-Label Issues

on:
  issues:
    types: [opened]

permissions:
  issues: write

jobs:
  auto-label:
    runs-on: ubuntu-latest
    steps:
      - name: Classify and label issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          set -euo pipefail

          # Check that the API key is configured
          if [[ -z "${OPENAI_API_KEY:-}" ]]; then
            echo "::warning::OPENAI_API_KEY secret not set. Skipping auto-labeling."
            exit 0
          fi

          # Truncate body to ~2000 chars to limit token usage
          body="${ISSUE_BODY:0:2000}"

          # Build the system prompt (static, no user input interpolated here).
          # The structured output schema below guarantees valid JSON, so the
          # prompt only needs to describe what each label means.
          system_prompt='You are a GitHub issue classifier for shrinkray, a video transcoding app (Go backend, web UI, FFmpeg).

          Pick exactly 1 type label and 0-3 area labels for the issue.

          type labels:
          - type/bug: Something is not working
          - type/feature: New feature request
          - type/enhancement: Improvement to existing functionality
          - type/docs: Documentation improvements
          - type/chore: Maintenance, deps, tooling
          - type/security: Security vulnerability or concern
          - type/question: Question or discussion

          area labels (only pick areas clearly relevant to the issue):
          - area/backend: Go backend, API, server
          - area/web-ui: Frontend web interface
          - area/ffmpeg: FFmpeg, encoding, transcoding
          - area/hwaccel: NVENC, QSV, VAAPI, VideoToolbox hardware acceleration
          - area/vmaf: VMAF scoring, SmartShrink quality presets
          - area/docker: Docker, containerization
          - area/ci: CI/CD, GitHub Actions'

          # Build JSON payload with jq (handles all escaping of user input safely).
          # response_format uses OpenAI structured output: the API constrains the
          # model to return JSON matching this schema exactly, so we never need to
          # parse markdown fences or fix malformed output.
          payload=$(jq -n \
            --arg system "$system_prompt" \
            --arg title "$ISSUE_TITLE" \
            --arg body "$body" \
            '{
              model: "gpt-4.1-mini",
              messages: [
                {role: "system", content: $system},
                {role: "user", content: ("Issue title: " + $title + "\n\nIssue body: " + $body)}
              ],
              temperature: 0,
              max_tokens: 200,
              response_format: {
                type: "json_schema",
                json_schema: {
                  name: "issue_labels",
                  strict: true,
                  schema: {
                    type: "object",
                    required: ["labels"],
                    additionalProperties: false,
                    properties: {
                      labels: {
                        type: "array",
                        items: {
                          type: "string",
                          enum: [
                            "type/bug", "type/feature", "type/enhancement",
                            "type/docs", "type/chore", "type/security", "type/question",
                            "area/backend", "area/web-ui", "area/ffmpeg",
                            "area/hwaccel", "area/vmaf", "area/docker", "area/ci"
                          ]
                        }
                      }
                    }
                  }
                }
              }
            }')

          # Call OpenAI API
          response=$(curl -s -w "\n%{http_code}" \
            --max-time 30 \
            "https://api.openai.com/v1/chat/completions" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d "$payload")

          # Split response body and HTTP status code
          http_code=$(echo "$response" | tail -1)
          response_body=$(echo "$response" | sed '$d')

          if [[ "$http_code" != "200" ]]; then
            echo "::warning::OpenAI API returned HTTP ${http_code}. Skipping auto-labeling."
            echo "Response: ${response_body}"
            exit 0
          fi

          # Extract the content from the response
          content=$(echo "$response_body" | jq -r '.choices[0].message.content // empty')

          if [[ -z "$content" ]]; then
            echo "::warning::OpenAI returned empty content. Skipping auto-labeling."
            exit 0
          fi

          # Structured output guarantees valid JSON with only enum-allowed values.
          # Parse the labels array directly.
          labels=$(echo "$content" | jq -r '.labels[]' 2>/dev/null || true)

          if [[ -z "$labels" ]]; then
            echo "::warning::Could not parse labels from response: ${content}"
            exit 0
          fi

          echo "Labels from AI:"
          applied=0
          while IFS= read -r label; do
            echo "  Applying: $label"
            gh issue edit "$ISSUE_NUMBER" --add-label "$label" --repo "${{ github.repository }}" || echo "  ::warning::Failed to apply $label"
            applied=$((applied + 1))
          done <<< "$labels"

          echo "Applied ${applied} label(s) to issue #${ISSUE_NUMBER}."
